# Greedy String Tiling (GST)

_Данный алгоритм предназначен для сравнения пар строк с целью определения степени их схожести. С некоторыми ограничениями, GST - это достоверная метрика; в исключительных случаях можно использовать приближенные значения. Главная задача алгоритма - расчет GST-значений. Изначальная область применения алгоритма - это обнаружение возможного плагиата в исходном коде программ и просто в разных текстовых документах. Так или иначе, этот алгоритм может быть использован и в задачах другого рода, например, сравнение последовательностей аминокислот в ДНК._

## Подготовка

Перед использованием алгоритма, нам нужно определиться с "токенизацией" строк. Другими словами, нам нужно разбить строки на мельчайшие части, которые мы считаем важными и определяющими схожесть строк. Это могут быть как символы, так и целые термы, ключевые слова из языка (for, switch, ...). Именно токены внутри строк будут объектами сравнения и из них будут состоять "тайлы".

## Основные понятия

* Когда мы обращаемся к двум сравниваемым строкам, более короткая строка будет называться __паттерном__ или __паттерн-строкой__, а длинная будет называться __текстом__ или __текстовой строкой__.

* __Максимальное совпадение__ - это когда подстрока _P_p_ паттерн-строки начиная с p полностью  (элемент-к-элементу) совпадает с подстрокой _T_t_ текстовой строки начиная с t. Это совпадение подразумевается максимально длинным, т.е. до несовпадающих элементов, до конца строки или до "маркированного" элемента (определение см. ниже). Максимальное совпадение удобно записывать как _max_match(p, t, s)_, где _s_ - это длина совпадения. Максимальные совпадения - это временные и чаще всего не уникальные ассоциации, т.е. подстрока, формирующая одно максимальное совпадение, может быть частью нескольких других максимальных совпадений.

* __Тайл__ - это перманентная и уникальная (один-к-одному) ассоциация подстроки из P с совпадающей подстрокой из T. В процессе формирования тайла из максимального совпадения, токены этих двух подстрок __маркируются__, и таким образом эти токены больше не участвуют в последующих совпадениях. Тайл длины _s_, начинающийся с _P_p_ и _T_t_, записывается как tile(p, t, s).

При нахождении тайлов и максимальных совпадений, в некоторых ситуациях можно игнорировать короткие максимальные совпадения. Например, в контексте языков програмирования, очевидно, что максимальные совпадения длиной 1 или 2 токена не будут иметь особого смысла. Таким образом, стоит ввести еще одно понятие:

* __Длина минимального совпадения__ определяется числом так, что максимальные совпадения с длиной ниже этого числа игнорируются. Длина минимального совпадения может быть равна 1, но обычно это целочисленная величина больше 1.

В конце концов, обозначим длину текущего максимального совпадения как maxmatch. Эта длина больше или равна глобальной длине минимального совпадения.

## Псевдокод алгоритма

```
количество_токенов_в_тайлах := 0
ПОВТОРЯТЬ
    maxmatch := длина_минимального_совпадения
    ДЛЯ КАЖДОГО P_p начиная с первого немаркированного токена из P
        ДЛЯ КАЖДОГО T_t начиная с первого немаркированного токена из T
            j := 0
            ПОКА P_p+j = T_t+j И немаркировано(P_p+j) И немаркировано(T_t+j)
                j := j + 1
            ЕСЛИ j = maxmatch ТО 
                добавить match(p, t, j) в список совпадений длины j
            ИНАЧЕ ЕСЛИ j > maxmatch ТО 
                создать новый список совпадений с match(p, t, j)
                maxmatch := j
    ДЛЯ КАЖДОГО match(p, t, j) в списке
        ЕСЛИ НЕ закупорка ТО           /* Создание нового тайла */
            ДЛЯ j := 0 ДО maxmatch - 1
                маркировать_токен(P_p+j)
                маркировать_токен(T_t+j)
            количество_токенов_в_тайлах := количество_токенов_в_тайлах + maxmatch
ПОКА maxmatch != длина_минимального_совпадения
```

__NB:__ "НЕ закупорка", это когда ни один из токенов от P_p до P_p+maxmatch-1 и от T_t до T_t+maxmatch-1 не был маркирован при создании предыдущих тайлов.

## Текстовое описание алгоритма

Нахождение всех максимальных совпадений подразумевает, что мы начинаем искать совпадения начиная с длины минимального совпадения. Если максимальное совпадение такой длины найдено, то мы добавляем его в список. В противном случае, если найдено более длинное максимальное совпадение, то мы начинаем новый список и длина этого совпадения становится новым ориентиром длины. К тому времени, когда пройдены все немаркированные токены P, текущее значение длины и будет длиной наибольшего максимального совпадения при текущей маркировке токенов из P и T.

Во второй части каждой итерации алгоритма, все максимальные совпадения из списка либо становятся тайлами, либо остаются "закупоренными" предыдущими тайлами. Отметим, что при каждой итерации maxmatch будет монотонно уменьшаться до тех пор, пока не примет значение длины минимального совпадения. На этом работа алгоритма завершается, а результатом можно считать список тайлов или количество токенов в тайлах.

## Сложность алгоритма

```
    O(n^3)
```

## Источники

Оригинальная статья - [String Similarity via Greedy String Tiling and Running Karp−Rabin Matching](https://www.researchgate.net/publication/262763983_String_Similarity_via_Greedy_String_Tiling_and_Running_Karp-Rabin_Matching)